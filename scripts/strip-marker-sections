#!/bin/bash
#
# Strips TinyPilot marker sections from a file.
#
# The marker sections are used to add TinyPilot-specific configuration to a
# file and being able to override/regenerate it later on without having to
# properly parse the entire file.
#
# If the file contains marker sections, it removes the markers and any content
# in between them. If the file doesnâ€™t contain marker sections, this is a noop.

print_help() {
  cat << EOF
Usage: ${0##*/} [--help] target_file
Strips TinyPilot marker sections from a file.
  target_file: Path to file with marker sections.
  --help Display this help and exit.
EOF
}

# Parse command-line arguments.
while [[ "$#" -gt 0 ]]; do
  case "$1" in
    --help)
      print_help
      exit
      ;;
    *)
      TARGET_FILE="$1"
      shift
      ;;
  esac
done
readonly TARGET_FILE

# Ensure target file is specified.
if [[ -z "${TARGET_FILE}" ]]; then
  echo 'Input parameter missing: target_file' >&2
  exit 1
fi

# Ensure target file exists and is a file.
if [[ ! -f "${TARGET_FILE}" ]]; then
  echo "Not a file: ${TARGET_FILE}" >&2
  exit 1
fi

# Read the original file line by line, and remove marker sections.
# This is done by iterating through the lines, and only preserving those that
# are outside of marker sections.
preserved_lines=()
is_in_marker_section='false'
readonly MARKER_START='# --- AUTOGENERATED BY TINYPILOT - START ---'
readonly MARKER_END='# --- AUTOGENERATED BY TINYPILOT - END ---'
while IFS='' read -r line; do
  if [[ "${line}" == "${MARKER_END}" ]]; then
    if ! "${is_in_marker_section}"; then
      echo 'Unmatched end marker' >&2
      exit 1
    fi
    is_in_marker_section='false'
    continue
  fi
  if "${is_in_marker_section}" || [[ "${line}" == "${MARKER_START}" ]]; then
    is_in_marker_section='true'
    continue
  fi
  preserved_lines+=("${line}")
done < "${TARGET_FILE}"

if "${is_in_marker_section}"; then
  echo 'Unmatched start marker' >&2
  exit 1
fi

# Populate preserved lines to file.
printf "%s\n" "${preserved_lines[@]}" > "${TARGET_FILE}"
